import { test, expect } from '@playwright/test';

test.describe('Security and Vulnerability Testing - Comprehensive Security Analysis', () => {
  
  test('XSS (Cross-Site Scripting) prevention testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting XSS prevention testing');

    // Common XSS payloads to test
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '<img src="x" onerror="alert(\'XSS\')">',
      '<svg onload="alert(\'XSS\')">',
      'javascript:alert("XSS")',
      '<iframe src="javascript:alert(\'XSS\')">',
      '<div onclick="alert(\'XSS\')">Click me</div>',
      '"><script>alert("XSS")</script>',
      '\'"--><script>alert("XSS")</script>'
    ];

    // Test XSS in form inputs
    await page.goto('/write/1');
    
    const editor = page.locator('textarea, [contenteditable="true"]').first();
    
    if (await editor.isVisible({ timeout: 5000 })) {
      console.log('‚úì Editor found for XSS testing');
      
      for (let i = 0; i < Math.min(xssPayloads.length, 3); i++) {
        const payload = xssPayloads[i];
        
        // Clear and input XSS payload
        await editor.fill('');
        await editor.fill(payload);
        
        // Wait a moment for any potential script execution
        await page.waitForTimeout(1000);
        
        // Check if alert was triggered (which would indicate XSS vulnerability)
        const dialogPromise = page.waitForEvent('dialog', { timeout: 100 }).catch(() => null);
        const dialog = await dialogPromise;
        
        if (dialog) {
          console.log(`‚ùå XSS vulnerability detected with payload: ${payload}`);
          await dialog.dismiss();
          expect(false).toBe(true); // Fail test if XSS is possible
        } else {
          console.log(`‚úì XSS payload safely handled: ${payload.slice(0, 30)}...`);
        }
        
        // Clear the payload
        await editor.fill('');
      }
      
    } else {
      console.log('‚ÑπÔ∏è Editor not found for XSS testing');
    }

    // Test XSS in URL parameters
    const xssUrls = [
      '/?search=<script>alert("XSS")</script>',
      '/stories?title=<img src=x onerror=alert("XSS")>',
      '/profile?name=<svg onload=alert("XSS")>'
    ];

    for (const url of xssUrls) {
      await page.goto(url);
      await page.waitForTimeout(1000);
      
      // Check if any XSS executed
      const dialogPromise = page.waitForEvent('dialog', { timeout: 100 }).catch(() => null);
      const dialog = await dialogPromise;
      
      if (dialog) {
        console.log(`‚ùå XSS vulnerability in URL: ${url}`);
        await dialog.dismiss();
        expect(false).toBe(true);
      } else {
        console.log(`‚úì URL XSS safely handled: ${url}`);
      }
    }

    console.log('‚úÖ XSS prevention testing completed successfully');
  });

  test('CSRF (Cross-Site Request Forgery) protection testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting CSRF protection testing');

    // Test CSRF token presence
    await page.goto('/');
    
    // Look for CSRF tokens in meta tags
    const csrfMetaToken = await page.locator('meta[name="csrf-token"]').getAttribute('content');
    if (csrfMetaToken) {
      console.log('‚úì CSRF token found in meta tag');
    }

    // Test CSRF protection on forms
    const forms = page.locator('form');
    const formCount = await forms.count();
    
    if (formCount > 0) {
      console.log(`‚úì Found ${formCount} forms to test for CSRF protection`);
      
      for (let i = 0; i < Math.min(formCount, 3); i++) {
        const form = forms.nth(i);
        const csrfInput = form.locator('input[name="_token"], input[name="csrf"], input[name*="csrf"]');
        
        if (await csrfInput.count() > 0) {
          console.log(`‚úì Form ${i + 1} has CSRF protection token`);
        } else {
          console.log(`‚ÑπÔ∏è Form ${i + 1} may not have visible CSRF token (could be in headers)`);
        }
      }
    }

    // Test API endpoints for CSRF protection
    const apiEndpoints = [
      '/api/stories',
      '/api/chapters',
      '/api/ai/chat'
    ];

    for (const endpoint of apiEndpoints) {
      // Test POST request without CSRF token
      const response = await page.request.post(endpoint, {
        data: { test: 'csrf-test' }
      });
      
      // Should return 403, 401, or 422 for CSRF protection
      const status = response.status();
      if ([403, 401, 422].includes(status)) {
        console.log(`‚úì ${endpoint} has CSRF protection (status: ${status})`);
      } else if (status === 404) {
        console.log(`‚ÑπÔ∏è ${endpoint} not found (404) - endpoint may not exist`);
      } else {
        console.log(`‚ö†Ô∏è ${endpoint} returned status ${status} - CSRF protection unclear`);
      }
    }

    console.log('‚úÖ CSRF protection testing completed');
  });

  test('SQL Injection prevention testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting SQL injection prevention testing');

    // Common SQL injection payloads
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users --",
      "admin'--",
      "' OR 1=1 --",
      "1' AND (SELECT COUNT(*) FROM users) > 0 --"
    ];

    // Test SQL injection in API endpoints with parameters
    const testEndpoints = [
      { path: '/api/stories/1', method: 'GET' },
      { path: '/api/chapters/1', method: 'GET' }
    ];

    for (const endpoint of testEndpoints) {
      for (let i = 0; i < Math.min(sqlPayloads.length, 3); i++) {
        const payload = sqlPayloads[i];
        const testPath = endpoint.path.replace('1', encodeURIComponent(payload));
        
        try {
          const response = await page.request.get(testPath);
          const status = response.status();
          
          // Should return 400, 404, or 500 - not 200 with data
          if (status === 200) {
            const responseText = await response.text();
            if (responseText.includes('user') || responseText.includes('error') && responseText.includes('sql')) {
              console.log(`‚ùå Potential SQL injection vulnerability at ${testPath}`);
              expect(false).toBe(true);
            } else {
              console.log(`‚úì SQL payload safely handled at ${testPath}`);
            }
          } else {
            console.log(`‚úì SQL injection prevented at ${testPath} (status: ${status})`);
          }
          
        } catch (error) {
          console.log(`‚úì SQL injection attempt blocked: ${error.message}`);
        }
      }
    }

    // Test SQL injection in form inputs
    await page.goto('/stories');
    
    const searchInputs = page.locator('input[type="text"], input[type="search"], input[name*="search"]');
    const searchCount = await searchInputs.count();
    
    if (searchCount > 0) {
      const searchInput = searchInputs.first();
      
      for (let i = 0; i < Math.min(sqlPayloads.length, 2); i++) {
        const payload = sqlPayloads[i];
        
        await searchInput.fill(payload);
        await searchInput.press('Enter');
        
        await page.waitForTimeout(1000);
        
        // Check for SQL error messages
        const errorMessages = page.locator(':text("sql"), :text("database"), :text("mysql"), :text("postgres")');
        const errorCount = await errorMessages.count();
        
        if (errorCount > 0) {
          console.log(`‚ùå SQL error exposed with payload: ${payload}`);
          expect(false).toBe(true);
        } else {
          console.log(`‚úì SQL payload in search safely handled: ${payload.slice(0, 20)}...`);
        }
      }
    }

    console.log('‚úÖ SQL injection prevention testing completed successfully');
  });

  test('Authentication bypass and session security testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting authentication security testing');

    // Test direct access to protected routes without authentication
    const protectedRoutes = [
      '/api/stories',
      '/api/chapters',
      '/api/ai/chat',
      '/dashboard',
      '/write/1',
      '/settings'
    ];

    let properlyProtected = 0;
    
    for (const route of protectedRoutes) {
      try {
        let response;
        
        if (route.startsWith('/api/')) {
          response = await page.request.get(route);
          const status = response.status();
          
          if ([401, 403].includes(status)) {
            console.log(`‚úì ${route} properly protected (${status})`);
            properlyProtected++;
          } else if (status === 404) {
            console.log(`‚ÑπÔ∏è ${route} not found (404)`);
          } else {
            console.log(`‚ö†Ô∏è ${route} returned status ${status} - may not be properly protected`);
          }
        } else {
          await page.goto(route);
          await page.waitForTimeout(1000);
          
          const currentUrl = page.url();
          const hasAuthPrompt = await page.locator(':text("sign in"), :text("login"), button:has-text("Sign in")').count() > 0;
          const isLoginRedirect = currentUrl.includes('/login') || currentUrl.includes('/auth');
          
          if (hasAuthPrompt || isLoginRedirect) {
            console.log(`‚úì ${route} requires authentication`);
            properlyProtected++;
          } else {
            console.log(`‚ÑπÔ∏è ${route} accessible without authentication`);
          }
        }
        
      } catch (error) {
        console.log(`‚úì ${route} access blocked: ${error.message}`);
        properlyProtected++;
      }
    }

    console.log(`üìä Authentication protection: ${properlyProtected}/${protectedRoutes.length} routes properly protected`);

    // Test session management
    await page.goto('/');
    
    const cookies = await page.context().cookies();
    const authCookies = cookies.filter(cookie => 
      cookie.name.toLowerCase().includes('auth') || 
      cookie.name.toLowerCase().includes('session') ||
      cookie.name.toLowerCase().includes('token')
    );

    if (authCookies.length > 0) {
      console.log(`‚úì Found ${authCookies.length} authentication cookies`);
      
      authCookies.forEach(cookie => {
        if (cookie.httpOnly) {
          console.log(`‚úì Cookie ${cookie.name} is HttpOnly (secure)`);
        } else {
          console.log(`‚ö†Ô∏è Cookie ${cookie.name} is not HttpOnly (potential security risk)`);
        }
        
        if (cookie.secure) {
          console.log(`‚úì Cookie ${cookie.name} has Secure flag`);
        }
        
        if (cookie.sameSite && cookie.sameSite !== 'None') {
          console.log(`‚úì Cookie ${cookie.name} has SameSite protection`);
        }
      });
    }

    console.log('‚úÖ Authentication security testing completed');
  });

  test('Input validation and sanitization testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting input validation testing');

    // Malicious input patterns
    const maliciousInputs = [
      '../../../etc/passwd', // Directory traversal
      '{{7*7}}', // Template injection
      '${7*7}', // Expression injection
      '<%= 7*7 %>', // Server-side template injection
      'null', // Null injection
      'undefined',
      '{}', // Object injection
      '[]',
      'true',
      'false',
      '0',
      '-1',
      '999999999999999999999', // Large number
      'A'.repeat(10000), // Very long string
      '\\x00', // Null byte
      '%00',
      '\n\r\n\r', // CRLF injection
    ];

    // Test input validation in forms
    await page.goto('/write/1');
    
    const editor = page.locator('textarea, input[type="text"]').first();
    
    if (await editor.isVisible({ timeout: 3000 })) {
      console.log('‚úì Input field found for validation testing');
      
      for (let i = 0; i < Math.min(maliciousInputs.length, 5); i++) {
        const input = maliciousInputs[i];
        
        await editor.fill(input);
        await page.waitForTimeout(500);
        
        // Check if input caused any errors or unexpected behavior
        const errorElements = page.locator('.error, .alert-danger, :text("error")');
        const errorCount = await errorElements.count();
        
        const currentValue = await editor.inputValue() || await editor.textContent() || '';
        
        if (currentValue === input) {
          console.log(`‚úì Input accepted and properly handled: ${input.slice(0, 20)}...`);
        } else {
          console.log(`‚úì Input sanitized or rejected: ${input.slice(0, 20)}...`);
        }
      }
    }

    // Test file upload security (if file upload exists)
    const fileInputs = page.locator('input[type="file"]');
    const fileInputCount = await fileInputs.count();
    
    if (fileInputCount > 0) {
      console.log(`‚úì Found ${fileInputCount} file upload fields`);
      
      // Test malicious file extensions (simulated)
      const maliciousExtensions = ['.exe', '.php', '.jsp', '.asp', '.bat', '.cmd'];
      
      for (const ext of maliciousExtensions) {
        console.log(`‚ÑπÔ∏è Would test upload rejection for ${ext} files`);
        // Note: Not actually uploading files in test environment
      }
    }

    // Test API input validation
    const apiTestData = [
      { endpoint: '/api/ai/chat', data: { message: '../../etc/passwd' } },
      { endpoint: '/api/ai/analyze', data: { content: '<script>alert("test")</script>' } },
      { endpoint: '/api/stories', data: { title: 'A'.repeat(1000) } }
    ];

    for (const test of apiTestData) {
      try {
        const response = await page.request.post(test.endpoint, { data: test.data });
        const status = response.status();
        
        if ([400, 401, 403, 422].includes(status)) {
          console.log(`‚úì ${test.endpoint} validates input properly (${status})`);
        } else {
          console.log(`‚ÑπÔ∏è ${test.endpoint} returned status ${status}`);
        }
        
      } catch (error) {
        console.log(`‚úì ${test.endpoint} request blocked: ${error.message}`);
      }
    }

    console.log('‚úÖ Input validation testing completed');
  });

  test('Authorization and privilege escalation testing', async ({ page }) => {
    console.log('üõ°Ô∏è Starting authorization and privilege escalation testing');

    // Test role-based access control
    await page.goto('/');
    
    // Test access to admin-specific endpoints
    const adminEndpoints = [
      '/api/admin',
      '/api/manage',
      '/api/users',
      '/admin',
      '/manage'
    ];

    let blockedEndpoints = 0;
    
    for (const endpoint of adminEndpoints) {
      try {
        let response;
        
        if (endpoint.startsWith('/api/')) {
          response = await page.request.get(endpoint);
          const status = response.status();
          
          if ([401, 403, 404].includes(status)) {
            console.log(`‚úì ${endpoint} access properly restricted (${status})`);
            blockedEndpoints++;
          } else {
            console.log(`‚ö†Ô∏è ${endpoint} returned status ${status} - check authorization`);
          }
        } else {
          await page.goto(endpoint);
          
          const notFound = await page.locator(':text("404"), :text("Not Found")').count();
          const accessDenied = await page.locator(':text("Access Denied"), :text("Forbidden")').count();
          
          if (notFound > 0 || accessDenied > 0) {
            console.log(`‚úì ${endpoint} access properly restricted`);
            blockedEndpoints++;
          } else {
            console.log(`‚ÑπÔ∏è ${endpoint} may be accessible`);
          }
        }
        
      } catch (error) {
        console.log(`‚úì ${endpoint} access blocked: ${error.message}`);
        blockedEndpoints++;
      }
    }

    console.log(`üìä Authorization: ${blockedEndpoints}/${adminEndpoints.length} admin endpoints properly protected`);

    // Test parameter tampering
    const parameterTests = [
      { path: '/api/stories/1', tampered: '/api/stories/999999' },
      { path: '/api/chapters/1', tampered: '/api/chapters/admin' },
    ];

    for (const test of parameterTests) {
      try {
        const response = await page.request.get(test.tampered);
        const status = response.status();
        
        if ([401, 403, 404].includes(status)) {
          console.log(`‚úì Parameter tampering blocked: ${test.tampered} (${status})`);
        } else {
          console.log(`‚ÑπÔ∏è Parameter tampering returned ${status}: ${test.tampered}`);
        }
        
      } catch (error) {
        console.log(`‚úì Parameter tampering blocked: ${error.message}`);
      }
    }

    console.log('‚úÖ Authorization testing completed');
  });

  test('Information disclosure and error handling security', async ({ page }) => {
    console.log('üõ°Ô∏è Starting information disclosure testing');

    // Test error handling - should not expose sensitive information
    const errorTriggers = [
      '/api/nonexistent-endpoint',
      '/api/stories/invalid-id',
      '/invalid-route-123456',
      '/api/ai/chat/malformed'
    ];

    for (const endpoint of errorTriggers) {
      try {
        const response = await page.request.get(endpoint);
        const responseText = await response.text();
        
        // Check for sensitive information in error messages
        const sensitivePatterns = [
          /database/i,
          /sql/i,
          /password/i,
          /secret/i,
          /key/i,
          /token/i,
          /stack trace/i,
          /exception/i,
          /\.js:\d+/i, // JavaScript file paths with line numbers
          /\/home\/|\/usr\/|\/var\//i, // Unix paths
          /c:\\/i // Windows paths
        ];

        let informationLeakage = false;
        for (const pattern of sensitivePatterns) {
          if (pattern.test(responseText)) {
            console.log(`‚ö†Ô∏è Potential information disclosure at ${endpoint}: ${pattern}`);
            informationLeakage = true;
            break;
          }
        }

        if (!informationLeakage) {
          console.log(`‚úì ${endpoint} handles errors securely`);
        }
        
      } catch (error) {
        console.log(`‚úì ${endpoint} error properly handled`);
      }
    }

    // Test for debug mode or development information
    await page.goto('/');
    
    const pageContent = await page.content();
    const debugPatterns = [
      /debug.*true/i,
      /development.*mode/i,
      /console\.log/i,
      /debugger/i
    ];

    let debugInfoFound = false;
    for (const pattern of debugPatterns) {
      if (pattern.test(pageContent)) {
        console.log(`‚ö†Ô∏è Debug information found in page source`);
        debugInfoFound = true;
        break;
      }
    }

    if (!debugInfoFound) {
      console.log('‚úì No debug information exposed in production');
    }

    // Check response headers for information disclosure
    const response = await page.request.get('/');
    const headers = response.headers();
    
    const sensitiveHeaders = ['x-powered-by', 'server', 'x-aspnet-version'];
    const securityHeaders = ['x-frame-options', 'x-content-type-options', 'x-xss-protection'];
    
    sensitiveHeaders.forEach(header => {
      if (headers[header]) {
        console.log(`‚ö†Ô∏è Sensitive header exposed: ${header}: ${headers[header]}`);
      } else {
        console.log(`‚úì Sensitive header ${header} not exposed`);
      }
    });

    securityHeaders.forEach(header => {
      if (headers[header]) {
        console.log(`‚úì Security header present: ${header}: ${headers[header]}`);
      } else {
        console.log(`‚ÑπÔ∏è Security header missing: ${header}`);
      }
    });

    console.log('‚úÖ Information disclosure testing completed');
  });
});